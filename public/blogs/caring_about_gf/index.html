<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Why Should We Care About Gradient Flows? | Chris Nemeth</title>
<meta name="keywords" content="gradient flows, optimization, sampling">
<meta name="description" content="Blog post on gradient flows in Euclidean and Wasserstein spaces.">
<meta name="author" content="Rui-Yang Zhang,&thinsp;Christopher Nemeth">
<link rel="canonical" href="https://chris-nemeth.github.io/blogs/caring_about_gf/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e690afcd5c523330d5c8b4d746eb158361600a015e99518d4d246a6ccab0cc19.css" integrity="sha256-5pCvzVxSMzDVyLTXRusVg2FgCgFemVGNTSRqbMqwzBk=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://chris-nemeth.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://chris-nemeth.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://chris-nemeth.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://chris-nemeth.github.io/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://chris-nemeth.github.io/blogs/caring_about_gf/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Why Should We Care About Gradient Flows?" />
<meta property="og:description" content="Blog post on gradient flows in Euclidean and Wasserstein spaces." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chris-nemeth.github.io/blogs/caring_about_gf/" />
<meta property="og:image" content="https://chris-nemeth.github.io/wasserstein_tangent.png" /><meta property="article:section" content="blogs" />
<meta property="article:published_time" content="2024-09-13T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-09-13T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://chris-nemeth.github.io/wasserstein_tangent.png" />
<meta name="twitter:title" content="Why Should We Care About Gradient Flows?"/>
<meta name="twitter:description" content="Blog post on gradient flows in Euclidean and Wasserstein spaces."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://chris-nemeth.github.io/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Why Should We Care About Gradient Flows?",
      "item": "https://chris-nemeth.github.io/blogs/caring_about_gf/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why Should We Care About Gradient Flows?",
  "name": "Why Should We Care About Gradient Flows?",
  "description": "Blog post on gradient flows in Euclidean and Wasserstein spaces.",
  "keywords": [
    "gradient flows", "optimization", "sampling"
  ],
  "articleBody": "Optimisation is a fundamental task in modern-day statistics and machine learning. A large set of problems in machine learning and statistics can be easily phrased as an optimisation problem - given some objective function $f$ defined on a domain $\\mathcal{X}$, we wish to find a point $x \\in \\mathcal{X}$ that minimises $f$ (or maximises $-f$). Sometimes, we do not even need to find the global minimum of $f$, and a sufficiently close local minimum would be good too.\nGradient Flows in the Euclidean Space A common optimisation algorithm is the gradient descent. If our objective function $f$ defined on the Euclidean space $\\mathbb{R}^d$ is continuous and we can compute its gradient $\\nabla f$, then, the gradient descent algorithm will iteratively apply the following update\n$$ x_{n+1} = x_n - h \\nabla f(x_n) $$\nuntil we converge or reach a termination point. The parameter $h\u003e0$ above is the step size of our algorithm, often referred to as a learning rate and it is a tuning parameter of the gradient descent algorithm. When we set $h$ to be very small, and let it tend to zero, we would convert the above discrete-in-time algorithm into a continuous-in-time algorithm, described as\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} x_t = -\\nabla f(x_t) $$\nwhere we use $t$ instead of $n$ to denote the time index as we are in continuous time rather than discrete time. Notice that for the above ordinary differential equation (ODE), after an Euler discretisation (of time), will become the gradient descent algorithm. The ODE is known as the gradient flow (in Euclidean space), and we can show that various frequently used algorithms can be interpreted as different discretisations of the gradient flow. For example, an implicit Euler discretisation of the gradient flow gives us the proximal point algorithm.\nOne can certainly see the conceptual benefit of considering gradient flow for understanding discrete-in-time optimisation algorithms - we suddenly have a simple, elegant mental picture of the limiting case of these procedures. However, rather unfortunately, the gradient flow in Euclidean space could not help us that much more than that. Often in theoretical analysis of iterative algorithms, we are interested in the convergence rate of these algorithms to some target value, and in the cases where approximations happen in the algorithms, we are interested in capturing the errors induced. Because of the discretisation in time, we could not translate many of the theories about gradient flow in Euclidean space into their discrete-in-time counterparts. This is the main reason why although gradient flows are extremely natural and tempting to investigate, they have not been considered as much, until very recently.\nThe Langevin Diffusion A major breakthrough, at least from a theoretical perspective, happened with Jordan, Kinderlehrer \u0026 Otto’s 1998 paper The Variational Formulation of the Fokker-Planck Equation . In there, the authors made an explicit connection between the Langevin diffusion, a particular type of Stochastic Differential Equation (SDE) with very nice equilibrium properties, and a gradient flow in the space of probability distributions. The Langevin diffusion can be characterised by the SDE\n$$ \\mathrm{d}X_t = \\nabla \\log \\pi(X_t) \\mathrm{d}t + \\sqrt{2}\\mathrm{d}B_t $$\nwhere ${B_t}$ is a Brownian motion and $\\pi$ is the equilibrium distribution of the process, and it could also be characterised by the Fokker-Planck equation\n$$ \\partial_t p_t(x) = \\text{div} \\left( p_t(x) \\nabla \\log \\frac{p_t(x)}{\\pi(x)} \\right) $$\nwhere $p_t(x)$ is the probability distribution of $X_t$. Naively, one can think about the two characterisations of the Langevin diffusion as a state space version and a distribution space version of the same motion.\nhttps://twitter.com/i/status/1775387754664198278 So, the paper of JKO1998 established that the Fokker-Planck equation of the Langevin diffusion is equivalent to a gradient flow in the Wasserstein space with the objective function being the KL divergence $f(\\cdot) = \\text{KL}(\\cdot | \\pi)$ where\n$$ \\text{KL}(p| q) := \\int p(x) \\log[p(x) / q(x)] dx = \\mathbb{E}_{X \\sim p} [\\log ( p(X)/q(X)) ]. $$\nIntuitively, what this connection tells us is that the particles following a Langevin diffusion are moving - in the steepest direction - towards their equilibrium distribution.\nAs an example, let’s assume that our target distribution of interest $p$ is a Gaussian $\\mathcal{N}(0,1)$ and particles are represented by the distribution $q$. As seen in the following movie, we can use the Wasserstein gradient flow of KL divergence to sequentially evolve $q$ and minimise the KL divergence.\n(Thanks to Louis Sharrock for creating this movie)\nThis result seems neat, but what is so special about this Langevin diffusion? It turns out that the Langevin diffusion is rather fundamental in sampling algorithms for computational statistics.\nMonte Carlo Sampling In statistics, especially in Bayesian statistics, we would often run into the problem of having a complicated probability distribution that we wish to compute expectations of, such as in the case of computing the posterior mean of a parameter of interest. If the distribution is complex and we cannot analytically evaluate our expectations of interest, then we often rely on using (independent) samples from the distribution to form an empirical approximation of the distribution. To be more precise, if we have a target probability distribution $\\pi$, we will get a sequence of independent samples $X_1, X_2, \\ldots, X_n \\sim \\pi$ and we have\n$$ \\pi(x) \\approx \\frac{1}{n} \\sum_{k=1}^n 1_{X_k}(x) $$\nwhere $1_{X_k}(x)$ is the indicator function that takes the value 1 when $x = X_k$ and zero otherwise. This is the Monte Carlo method, and it can be shown that under weak conditions of the target distribution $\\pi$, the empirical distribution converges to $\\pi$ at a rate of $O(1/\\sqrt{n})$ for $n$ Monte Carlo samples. The only problem with the Monte Carlo method is, how do we get those samples? As alluded slightly from the Langevin diffusion, since we can set the equilibrium distribution of a Langevin diffusion to (almost) any target distribution and the process will converge to it after running for a while, we can just start the SDE at some point and run it for long enough so it hits the equilibrium, and use the trajectories afterwards as samples from the target distribution.\nImmediately, we would ask - how exactly do we simulate a continuous-in-time SDE? The simplest solution is to use the Euler-Maruyama scheme and obtain discretisations using the following iterative procedure\n$$ X_{(n+1)h} = X_{nh} + h \\nabla \\log \\pi(X_{nh})+\\sqrt{2h} \\xi $$\nwhere $\\xi \\sim N(0,1)$. This gives us the unadjusted Langevin algorithm (ULA), also known as the Langevin Monte Carlo (LMC) algorithm in the machine learning literature.\nSince this is a discretisation, it introduces some numerical errors (the precise reason for the errors will be explained in a bit) and by using ULA we will not obtain exact samples from the target distribution $\\pi$. For sufficiently small $h$, the error would be tolerable. We could also do smart things such as Metropolis adjustments to remove the error, and we would recover the Metropolis Adjusted Langevin Algorithm (MALA) which is a staple of the Markov chain Monte Carlo (MCMC) algorithms for computational statistics. More thorough discussions on MCMC algorithms can be found in textbooks such as Monte Carlo Statistical Methods by Robert \u0026 Casella, or the recent Scalable Monte Carlo for Bayesian Learning by Fearnhead, Nemeth, Oates \u0026 Sherlock. One could also find a more detailed theoretical study of ULA in Roberts \u0026 Tweedie’s 1996 paper Exponential Convergence of Langevin Distributions and their Discrete Approximations .\nWasserstein Gradient Flow - a Bridge between Sampling and Optimisation So far, we have learnt that the Langevin diffusion can be viewed as a gradient flow, and the discrete-in-time version of the Langevin diffusion allows us to draw samples from a target distribution. It turns out that we can also interpret the discrete Langevin diffusion of the LMC as a discrete-in-time approximation of the corresponding gradient flow in the space of probability distributions (to be more precise, the Wasserstein space, so we would often call this type of gradient flow a Wasserstein gradient flow).\nIn the 2018 paper Sampling as Optimization in the Space of Measures by Wibisono, the author pointed out that the LMC as an Euler-Maruyama discretisation of the Langevin diffusion can be viewed as a forward-flow splitting discretisation of the Wasserstein gradient flow with the objective function being the KL divergence. The forward-flow splitting scheme is a way to discretise time by doing half a step of forward discretisation, and half a step of flow discretisation, for each full step of the iteration. The expression of the two discretisations is slightly involved to describe in the space of probability distributions, but if we translate them into the state space, it is simply\n$$ \\text{(forward)} \\ X_{(n+1/2)h} = X_{nh} + h \\nabla \\log \\pi(X_{nh}), $$ $$ \\text{(flow)} \\ X_{(n+1)h} = X_{(n+1/2)h} + \\sqrt{2h} \\xi $$ with $\\xi \\sim N(0,1)$, which combines to give us the full LMC update. Another observation in Wibisono (2018) is that, if we swap the flow step with a backward discretisation step, we would be able to cancel the error of discretising the Langevin diffusion. Unfortunately, the backward step is not implementable in general. Nevertheless, this paper provides us with the very important information that there exists a hidden connection between sampling (using LMC) and optimisation (using gradient flows). A bridge between the two areas has been formally built at this point.\nTo further utilise the power of this connection, Durmus, Majewski \u0026 Miasojedow in their 2019 paper Analysis of Langevin Monte Carlo via Convex Optimization provided us with a more explicit characterisation of the error of LMC using convergence analysis of the Wasserstein gradient flow. Unlike in the case of gradient flows in Euclidean space, the theoretical studies of Wasserstein gradient flows can actually be used in the analysis of their discrete-in-time counterparts.\nWhat Else Can We Do? At this point, it should be clear that the connection between sampling and optimisation established using Wasserstein gradient flows is promising and potentially very useful.\nOne immediate area of work is to interpret existing sampling algorithms as gradient flows, and use these realisations to help us better understand the properties of these algorithms. There are already some successful fruits from this branch:\nLiu’s 2017 paper Stein Variational Gradient Descent as Gradient Flow interpreted the Stein Variational Gradient Descent algorithm, a powerful sampling algorithm, as a type of gradient flow. Duncan, Nüsken \u0026 Szpruch’s 2023 paper On the Geometry of Stein Variational Gradient Descent built on the above realisation and showed several convergence results about the algorithm, as well as certain improvements based on such gradient flow analysis. Nüsken’s 2024 paper Stein Transport for Bayesian Learning proposed a promising new algorithm Stein Transport that extends the Stein Variational Gradient Descent by tweaking the geometry of the Wassterstein gradient flow. Chopin, Crucinio \u0026 Korba’s 2024 paper A connection between Tempering and Entropic Mirror Descent has established that tempering sequential Monte Carlo algorithms can be viewed as a type of discretisation of the gradient flow in the Fisher-Rao geometry. In addition, a class of work that could be made possible with this new connection is those that translate algorithmic tricks from one field (say optimisation) to another (say sampling). A very nice example of this thinking is the line of work by Sharrock, Nemeth and coauthors over recent years. A lot of optimisation algorithms involve tuning parameters (also known as learning rates) that have to be manually adjusted, and different specifications of them will sometimes yield very different performance of the algorithms. To tackle the difficulties of tuning such parameters, there is a class of learning-rate-free algorithms that replace the tuning of learning rates with an automatic mechanism. With the help of the connection between sampling and optimisation made by gradient flows, recent work has managed to replace the manually-tuned learning rates of sampling algorithms with automatic, learning-rate-free ones, as shown in the papers such as Coin Sampling: Gradient-Based Bayesian Inference without Learning Rates and Learning Rate Free Sampling in Constrained Domains .\nOverall, gradient flows and related ideas have become a promising tool for investigating theoretical properties of sampling algorithms, and have shown a considerable amount of potential to inspire designs of new sampling algorithms. There remains a vast pool of unanswered questions and possible extensions in this area. More breakthroughs are to be expected from this line of work.\nP.S. A book-length, formal introduction to the material covered above and more can be found in Statistical Optimal Transport [https://arxiv.org/abs/2407.18163 ] by Chewi, Niles-Weed \u0026 Rigollet.\n",
  "wordCount" : "2057",
  "inLanguage": "en",
  "image":"https://chris-nemeth.github.io/wasserstein_tangent.png","datePublished": "2024-09-13T00:00:00Z",
  "dateModified": "2024-09-13T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Rui-Yang Zhang"
  }, {
    "@type": "Person",
    "name": "Christopher Nemeth"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://chris-nemeth.github.io/blogs/caring_about_gf/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Chris Nemeth",
    "logo": {
      "@type": "ImageObject",
      "url": "https://chris-nemeth.github.io/favicon.ico"
    }
  }
}
</script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: "\\begin{equation}", right: "\\end{equation}", display: true},
            {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
            {left: "\\begin{align}", right: "\\end{align}", display: true},
            {left: "\\begin{align*}", right: "\\end{align*}", display: true},
            {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
            {left: "\\begin{gather}", right: "\\end{gather}", display: true},
            {left: "\\begin{CD}", right: "\\end{CD}", display: true},
          ],
          throwOnError : false
        });
    });
</script>
 


</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://chris-nemeth.github.io/" accesskey="h" title="Chris Nemeth">
                <img src="https://chris-nemeth.github.io/favicon.ico" alt="" aria-label="logo"
                    height="18"
                    width="18">Chris Nemeth</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://chris-nemeth.github.io/papers/" title="Papers">
                    <span>Papers</span>
                </a>
            </li>
            <li>
                <a href="https://chris-nemeth.github.io/code_and_software/" title="Code">
                    <span>Code</span>
                </a>
            </li>
            <li>
                <a href="https://chris-nemeth.github.io/software/" title="Software">
                    <span>Software</span>
                </a>
            </li>
            <li>
                <a href="https://chris-nemeth.github.io/books/" title="Books">
                    <span>Books</span>
                </a>
            </li>
            <li>
                <a href="https://chris-nemeth.github.io/blogs/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://chris-nemeth.github.io/research_group/" title="Group">
                    <span>Group</span>
                </a>
            </li>
        </ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Why Should We Care About Gradient Flows?
    </h1>
    <div class="post-meta"><span title='2024-09-13 00:00:00 +0000 UTC'>September 2024</span>&nbsp;&middot;&nbsp;Rui-Yang Zhang,&thinsp;Christopher Nemeth

</div>
  </header> 
  <div class="post-content"><p>Optimisation is a fundamental task in modern-day statistics and machine learning. A large set of problems in machine learning and statistics can be easily phrased as an optimisation problem - given some objective function $f$ defined on a domain $\mathcal{X}$, we wish to find a point $x \in \mathcal{X}$ that minimises $f$ (or maximises $-f$). Sometimes, we do not even need to find the global minimum of $f$, and a sufficiently close local minimum would be good too.</p>
<hr>
<h2 id="gradient-flows-in-the-euclidean-space">Gradient Flows in the Euclidean Space</h2>
<p>A common optimisation algorithm is the <strong>gradient descent</strong>. If our objective function $f$ defined on the Euclidean space $\mathbb{R}^d$ is continuous and we can compute its gradient $\nabla f$, then, the gradient descent algorithm will iteratively apply the following update</p>
<p>$$
x_{n+1} = x_n - h \nabla f(x_n)
$$</p>
<p>until we converge or reach a termination point. The parameter $h&gt;0$ above is the step size of our algorithm, often referred to as a <em>learning rate</em> and it is a tuning parameter of the gradient descent algorithm. When we set $h$ to be very small, and let it tend to zero, we would convert the above discrete-in-time algorithm into a continuous-in-time algorithm, described as</p>
<p>$$
\frac{\mathrm{d}}{\mathrm{d}t} x_t = -\nabla f(x_t)
$$</p>
<p>where we use $t$ instead of $n$ to denote the time index as we are in continuous time rather than discrete time. Notice that for the above ordinary differential equation (ODE), after an Euler discretisation (of time), will become the gradient descent algorithm. The ODE is known as the <strong>gradient flow</strong> (in Euclidean space), and we can show that various frequently used algorithms can be interpreted as different discretisations of the gradient flow. For example, an implicit Euler discretisation of the gradient flow gives us the <strong>proximal point</strong> <strong>algorithm.</strong></p>
<p>One can certainly see the conceptual benefit of considering gradient flow for understanding discrete-in-time optimisation algorithms - we suddenly have a simple, elegant mental picture of the limiting case of these procedures. However, rather unfortunately, the gradient flow in Euclidean space could not help us that much more than that. Often in theoretical analysis of iterative algorithms, we are interested in the convergence rate of these algorithms to some target value, and in the cases where approximations happen in the algorithms, we are interested in capturing the errors induced. Because of the discretisation in time, we could not translate many of the theories about gradient flow in Euclidean space into their discrete-in-time counterparts. This is the main reason why although gradient flows are extremely natural and tempting to investigate, they have not been considered as much, until very recently.</p>
<hr>
<h2 id="the-langevin-diffusion">The Langevin Diffusion</h2>
<p>A major breakthrough, at least from a theoretical perspective, happened with Jordan, Kinderlehrer &amp; Otto’s 1998 paper <a href="https://doi.org/10.1137/S0036141096303359" target="_blank"><em>The Variational Formulation of the Fokker-Planck Equation</em></a>
. In there, the authors made an explicit connection between the <strong>Langevin diffusion</strong>, a particular type of Stochastic Differential Equation (SDE) with very nice equilibrium properties, and a gradient flow in the space of probability distributions. The Langevin diffusion can be characterised by the SDE</p>
<p>$$
\mathrm{d}X_t = \nabla \log \pi(X_t) \mathrm{d}t + \sqrt{2}\mathrm{d}B_t
$$</p>
<p>where ${B_t}$ is a Brownian motion and $\pi$ is the equilibrium distribution of the process, and it could also be characterised by the <strong>Fokker-Planck equation</strong></p>
<p>$$
\partial_t p_t(x) = \text{div} \left( p_t(x) \nabla \log \frac{p_t(x)}{\pi(x)} \right)
$$</p>
<p>where $p_t(x)$ is the probability distribution of $X_t$. Naively, one can think about the two characterisations of the Langevin diffusion as a state space version and a distribution space version of the same motion.</p>
<p><a href="https://twitter.com/i/status/1775387754664198278" target="_blank">https://twitter.com/i/status/1775387754664198278</a>
</p>
<p>So, the paper of JKO1998 established that the Fokker-Planck equation of the Langevin diffusion is equivalent to a gradient flow in the <strong>Wasserstein space</strong> with the objective function being the KL divergence $f(\cdot) = \text{KL}(\cdot | \pi)$ where</p>
<p>$$
\text{KL}(p| q) := \int p(x) \log[p(x) / q(x)] dx = \mathbb{E}_{X \sim p} [\log ( p(X)/q(X)) ].
$$</p>
<p>Intuitively, what this connection tells us is that the particles following a Langevin diffusion are moving - in the steepest direction - towards their equilibrium distribution.</p>
<p>As an example, let&rsquo;s assume that our target distribution of interest $p$ is a Gaussian $\mathcal{N}(0,1)$ and particles are represented by the distribution $q$. As seen in the following movie, we can use the Wasserstein gradient flow of KL divergence to sequentially evolve $q$ and minimise the KL divergence.</p>
<p><img loading="lazy" src="WGF.gif" alt=""  />

(Thanks to Louis Sharrock for creating this movie)</p>
<p>This result seems neat, but what is so special about this Langevin diffusion? It turns out that the Langevin diffusion is rather fundamental in sampling algorithms for computational statistics.</p>
<hr>
<h2 id="monte-carlo-sampling">Monte Carlo Sampling</h2>
<p>In statistics, especially in Bayesian statistics, we would often run into the problem of having a complicated probability distribution that we wish to compute expectations of, such as in the case of computing the posterior mean of a parameter of interest. If the distribution is complex and we cannot analytically evaluate our expectations of interest, then we often rely on using (independent) samples from the distribution to form an empirical approximation of the distribution. To be more precise, if we have a target probability distribution $\pi$, we will get a sequence of independent samples $X_1, X_2, \ldots, X_n \sim \pi$ and we have</p>
<p>$$
\pi(x) \approx \frac{1}{n} \sum_{k=1}^n 1_{X_k}(x)
$$</p>
<p>where $1_{X_k}(x)$ is the indicator function that takes the value 1 when $x = X_k$ and zero otherwise. This is the <strong>Monte Carlo method</strong>, and it can be shown that under weak conditions of the target distribution $\pi$, the empirical distribution converges to $\pi$ at a rate of $O(1/\sqrt{n})$ for $n$ Monte Carlo samples. The only problem with the Monte Carlo method is, how do we get those samples? As alluded slightly from the Langevin diffusion, since we can set the equilibrium distribution of a Langevin diffusion to (almost) any target distribution and the process will converge to it after running for a while, we can just start the SDE at some point and run it for long enough so it hits the equilibrium, and use the trajectories afterwards as samples from the target distribution.</p>
<p>Immediately, we would ask - how exactly do we simulate a continuous-in-time SDE? The simplest solution is to use the Euler-Maruyama scheme and obtain discretisations using the following iterative procedure</p>
<p>$$
X_{(n+1)h} = X_{nh} + h \nabla \log \pi(X_{nh})+\sqrt{2h} \xi
$$</p>
<p>where $\xi \sim N(0,1)$. This gives us the <strong>unadjusted Langevin algorithm</strong> (ULA), also known as the <strong>Langevin Monte Carlo</strong> (LMC) algorithm in the machine learning literature.</p>
<p>Since this is a discretisation, it introduces some numerical errors (the precise reason for the errors will be explained in a bit) and by using ULA we will not obtain exact samples from the target distribution $\pi$. For sufficiently small $h$, the error would be tolerable. We could also do smart things such as <strong>Metropolis adjustments</strong> to remove the error, and we would recover the <strong>Metropolis Adjusted Langevin Algorithm</strong> (MALA) which is a staple of the <strong>Markov chain Monte Carlo</strong> (MCMC) algorithms for computational statistics. More thorough discussions on MCMC algorithms can be found in textbooks such as <a href="https://link.springer.com/book/10.1007/978-1-4757-4145-2" target="_blank"><em>Monte Carlo Statistical Methods</em></a>
 by Robert &amp; Casella, or the recent <a href="https://arxiv.org/abs/2407.12751" target="_blank"><em>Scalable Monte Carlo for Bayesian Learning</em></a>
 by Fearnhead, Nemeth, Oates &amp; Sherlock. One could also find a more detailed theoretical study of ULA in Roberts &amp; Tweedie’s 1996 paper <a href="https://projecteuclid.org/journals/bernoulli/volume-2/issue-4/Exponential-convergence-of-Langevin-distributions-and-their-discrete-approximations/bj/1178291835.full" target="_blank"><em>Exponential Convergence of Langevin Distributions and their Discrete Approximations</em></a>
.</p>
<hr>
<h2 id="wasserstein-gradient-flow---a-bridge-between-sampling-and-optimisation">Wasserstein Gradient Flow - a Bridge between Sampling and Optimisation</h2>
<p>So far, we have learnt that the Langevin diffusion can be viewed as a gradient flow, and the discrete-in-time version of the Langevin diffusion allows us to draw samples from a target distribution. It turns out that we can also interpret the discrete Langevin diffusion of the LMC as a discrete-in-time approximation of the corresponding gradient flow in the space of probability distributions (to be more precise, the Wasserstein space, so we would often call this type of gradient flow a <em>Wasserstein gradient flow</em>).</p>
<p>In the 2018 paper <a href="https://arxiv.org/abs/1802.08089" target="_blank"><em>Sampling as Optimization in the Space of Measures</em></a>
 by Wibisono, the author pointed out that the LMC as an Euler-Maruyama discretisation of the Langevin diffusion can be viewed as a forward-flow splitting discretisation of the Wasserstein gradient flow with the objective function being the KL divergence. The forward-flow splitting scheme is a way to discretise time by doing half a step of forward discretisation, and half a step of flow discretisation, for each full step of the iteration. The expression of the two discretisations is slightly involved to describe in the space of probability distributions, but if we translate them into the state space, it is simply</p>
<p>$$
\text{(forward)} \ X_{(n+1/2)h} = X_{nh} + h \nabla \log \pi(X_{nh}),
$$
$$
\text{(flow)} \ X_{(n+1)h} = X_{(n+1/2)h} + \sqrt{2h} \xi
$$
with $\xi \sim N(0,1)$, which combines to give us the full LMC update. Another observation in Wibisono (2018) is that, if we swap the flow step with a backward discretisation step, we would be able to cancel the error of discretising the Langevin diffusion. Unfortunately, the backward step is not implementable in general. Nevertheless, this paper provides us with the very important information that there exists a hidden connection between sampling (using LMC) and optimisation (using gradient flows). A bridge between the two areas has been formally built at this point.</p>
<p>To further utilise the power of this connection, Durmus, Majewski &amp; Miasojedow in their 2019 paper <a href="https://arxiv.org/abs/1802.09188" target="_blank"><em>Analysis of Langevin Monte Carlo via Convex Optimization</em></a>
 provided us with a more explicit characterisation of the error of LMC using convergence analysis of the Wasserstein gradient flow. Unlike in the case of gradient flows in Euclidean space, the theoretical studies of Wasserstein gradient flows can actually be used in the analysis of their discrete-in-time counterparts.</p>
<hr>
<h2 id="what-else-can-we-do">What Else Can We Do?</h2>
<p>At this point, it should be clear that the connection between sampling and optimisation established using Wasserstein gradient flows is promising and potentially very useful.</p>
<p>One immediate area of work is to interpret existing sampling algorithms as gradient flows, and use these realisations to help us better understand the properties of these algorithms. There are already some successful fruits from this branch:</p>
<ul>
<li>Liu’s 2017 paper <a href="https://arxiv.org/abs/1704.07520" target="_blank"><em>Stein Variational Gradient Descent as Gradient Flow</em></a>
 interpreted the Stein Variational Gradient Descent algorithm, a powerful sampling algorithm, as a type of gradient flow.</li>
<li>Duncan, Nüsken &amp; Szpruch’s 2023 paper <a href="https://arxiv.org/abs/1912.00894" target="_blank"><em>On the Geometry of Stein Variational Gradient Descent</em></a>
 built on the above realisation and showed several convergence results about the algorithm, as well as certain improvements based on such gradient flow analysis.</li>
<li>Nüsken&rsquo;s 2024 paper <a href="https://arxiv.org/pdf/2409.01464" target="_blank"><em>Stein Transport for Bayesian Learning</em></a>
 proposed a promising new algorithm Stein Transport that extends the Stein Variational Gradient Descent by tweaking the geometry of the Wassterstein gradient flow.</li>
<li>Chopin, Crucinio &amp; Korba’s 2024 paper <a href="https://arxiv.org/abs/2310.11914" target="_blank"><em>A connection between Tempering and Entropic Mirror Descent</em></a>
 has established that tempering sequential Monte Carlo algorithms can be viewed as a type of discretisation of the gradient flow in the Fisher-Rao geometry.</li>
</ul>
<p>In addition, a class of work that could be made possible with this new connection is those that translate algorithmic tricks from one field (say optimisation) to another (say sampling). A very nice example of this thinking is the line of work by Sharrock, Nemeth and coauthors over recent years. A lot of optimisation algorithms involve tuning parameters (also known as learning rates) that have to be manually adjusted, and different specifications of them will sometimes yield very different performance of the algorithms. To tackle the difficulties of tuning such parameters, there is a class of <strong>learning-rate-free</strong> algorithms that replace the tuning of learning rates with an automatic mechanism. With the help of the connection between sampling and optimisation made by gradient flows, recent work has managed to replace the manually-tuned learning rates of sampling algorithms with automatic, learning-rate-free ones, as shown in the papers such as <a href="https://proceedings.mlr.press/v202/sharrock23a/sharrock23a.pdf" target="_blank"><em>Coin Sampling: Gradient-Based Bayesian Inference without Learning Rates</em></a>
 and <a href="https://proceedings.neurips.cc/paper_files/paper/2023/file/cdee6c3eaa2adc285f11da7711a75c12-Paper-Conference.pdf" target="_blank"><em>Learning Rate Free Sampling in Constrained Domains</em></a>
.</p>
<p>Overall, gradient flows and related ideas have become a promising tool for investigating theoretical properties of sampling algorithms, and have shown a considerable amount of potential to inspire designs of new sampling algorithms. There remains a vast pool of unanswered questions and possible extensions in this area. More breakthroughs are to be expected from this line of work.</p>
<p><strong>P.S.</strong> A book-length, formal introduction to the material covered above and more can be found in <em>Statistical Optimal Transport</em> [<a href="https://arxiv.org/abs/2407.18163" target="_blank">https://arxiv.org/abs/2407.18163</a>
] by Chewi, Niles-Weed &amp; Rigollet.</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://chris-nemeth.github.io/tags/gradient-flows/">Gradient Flows</a></li>
      <li><a href="https://chris-nemeth.github.io/tags/optimization/">Optimization</a></li>
      <li><a href="https://chris-nemeth.github.io/tags/sampling/">Sampling</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://chris-nemeth.github.io/">Chris Nemeth</a></span> ·     
    <span>
    Powered by 
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/pmichaillat/hugo-website/" rel="noopener" target="_blank">a modified version</a>
         of 
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>
</html>
